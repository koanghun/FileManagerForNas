# 텍스트 청킹 전략 분석 및 개선 방안

## 1. 현재 청킹 전략 (문자 기반 중첩 청킹)

현재 시스템은 `backend/main.py`의 `chunk_text` 함수를 통해 문자 기반의 중첩 청킹(Overlapping Chunking) 전략을 사용하고 있습니다.

-   **`chunk_size`**: 500자 (기본값)
-   **`chunk_overlap`**: 50자 (기본값)

**작동 방식:**
입력 텍스트를 500자 단위로 분할하며, 각 청크는 이전 청크와 50자만큼 중첩됩니다. 이는 청크 간의 컨텍스트를 유지하여 의미론적 검색의 정확도를 높이는 데 기여합니다.

**장점:**
-   구현이 간단합니다.
-   중첩을 통해 청크 경계에서 의미가 끊기는 것을 완화하고 컨텍스트 연속성을 제공합니다.

**단점:**
-   **의미론적 인식 부족:** 문장 경계, 단락 구분 등 텍스트의 자연스러운 구조를 고려하지 않고 단순히 문자 수에 따라 분할합니다. 이로 인해 문장이나 단어가 중간에 잘릴 수 있으며, 이는 임베딩 모델의 성능에 부정적인 영향을 미칠 수 있습니다.
-   **고정된 크기의 한계:** 모든 텍스트에 500자라는 고정된 청크 크기가 최적이지 않을 수 있습니다. 짧은 문맥에서는 너무 길고, 긴 문맥에서는 너무 짧을 수 있습니다.

## 2. 문장 기반 청킹 vs. 재귀적 문자 텍스트 분할기

### 문장 기반 청킹 (Sentence-based Chunking)

-   **원리:** 텍스트를 문장 단위로 분할합니다. 각 청크는 하나 이상의 완전한 문장으로 구성됩니다.
-   **작동 방식:** NLTK, spaCy와 같은 NLP 라이브러리의 문장 토크나이저를 사용하여 문장 경계를 식별합니다.
-   **장점:** 문장의 의미론적 무결성을 보존하여 언어 모델이 더 정확한 임베딩을 생성하도록 돕습니다.
-   **단점:** 문장이 매우 길면 청크가 여전히 커질 수 있습니다. 코드나 표와 같이 문장 구조가 명확하지 않은 텍스트에는 적합하지 않습니다.
-   **적합한 경우:** 기사, 에세이, 일반적인 산문 등 문장 단위의 의미가 중요한 텍스트.

### 재귀적 문자 텍스트 분할기 (Recursive Character Text Splitter)

-   **원리:** 여러 구분 기호(예: `

`, `
`, ` `) 목록을 사용하여 텍스트를 계층적으로 분할합니다. 가능한 한 큰 의미 단위(예: 단락)를 유지하면서 `chunk_size`를 초과하지 않도록 합니다.
-   **작동 방식:** 가장 큰 의미 단위의 구분 기호(예: `

` - 단락)부터 시도하여 텍스트를 분할합니다. 분할된 청크가 여전히 `chunk_size`보다 크면 다음 구분 기호(예: `
` - 줄)로 다시 분할하는 과정을 재귀적으로 반복합니다. 최종적으로 모든 구분 기호를 사용해도 청크가 너무 크면 문자 단위로 분할합니다.
-   **장점:**
    -   **계층적 컨텍스트 보존:** 단락, 문장 등 텍스트의 구조적 계층을 우선적으로 고려하여 의미 있는 블록을 유지합니다. 이는 소설과 같이 구조화된 긴 텍스트에 특히 유리합니다.
    -   **유연성 및 견고성:** 다양한 문서 유형과 서식 변화에 더 잘 대응할 수 있습니다.
    -   **균형 잡힌 청크:** 의미론적으로 일관되면서도 임베딩에 적절한 크기의 청크를 생성하는 데 효과적입니다.
-   **단점:** 구분 기호 목록의 설정이 중요하며, 최적의 성능을 위해 조정이 필요할 수 있습니다.
-   **적합한 경우:** 소설, 보고서, 코드 등 다양한 구조를 가진 일반적인 문서 처리.

## 3. 소설, 자막, 소개, 요약글 등을 위한 청킹 전략 제안

### 일반 산문 (소설, 소개, 요약글)

-   **문제점:** 현재 문자 기반 청킹은 문장이나 단락을 임의로 끊어 컨텍스트 손실을 유발할 수 있습니다.
-   **제안 전략:** **재귀적 문자 텍스트 분할기**를 사용하는 것이 가장 효과적입니다. 단락(`

`)을 우선적으로 분할하고, 그 다음 줄(`
`), 마지막으로 문자 단위로 분할함으로써 텍스트의 논리적 흐름과 계층적 컨텍스트를 최대한 보존할 수 있습니다. 이는 문장 기반 청킹보다 더 큰 의미 단위를 유지하는 데 유리합니다.

### 애니/영화 자막

-   **문제점:** 자막은 짧고 시간 동기화된 대화 조각이므로, 일반적인 청킹 방식은 관련 없는 대사를 묶거나 이미 완전한 생각을 분할할 수 있습니다.
-   **제안 전략:**
    -   **시간 기반 청킹 (시간 데이터가 있는 경우):** 특정 시간 범위 내의 자막을 그룹화하는 것이 가장 의미론적으로 적합합니다.
    -   **문장 기반 청킹 (매우 작은 `chunk_size` 및 `chunk_overlap`):** 각 자막 줄을 잠재적인 문장으로 처리하고, 필요한 경우 문장 토크나이저를 활용합니다.
    -   **자막 항목당 청킹 없음:** 각 자막 항목 자체가 이미 짧고 독립적인 의미 단위인 경우, 추가 분할 없이 각 항목을 하나의 청크로 간주하는 것이 가장 좋습니다.

## 4. 결론 및 다음 단계

소설, 소개, 요약글과 같은 일반 산문 콘텐츠의 정확한 인식을 위해서는 **재귀적 문자 텍스트 분할기**가 현재의 문자 기반 청킹보다 훨씬 더 효과적일 것으로 판단됩니다. 이는 텍스트의 계층적 구조를 존중하여 더 응집력 있는 청크를 생성하기 때문입니다.

**다음 단계:**
-   **재귀적 문자 텍스트 분할기 구현을 탐색합니다.**
-   이를 위해 `langchain-text-splitter` 라이브러리를 `requirements.txt`에 추가하여 활용하는 방안을 고려하거나, 필요시 사용자 지정 구현을 진행합니다.
-   `backend/main.py`의 `chunk_text` 함수를 새로운 전략으로 업데이트합니다.
